name: Build and Push Docker Image to GHCR

# Trigger on push tags starting with "v"
on:
  push:
    tags:
      - "v*"

permissions:
  contents: read
  packages: write

env:
  DOCKER_REPO: ghcr.io/${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      matrix:
        platform:
          - linux/amd64
          - linux/arm64

    steps:
      - name: Set variables
        id: vars
        run: |
          echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          # Replace '/' with '-' in platform strings to use as tag suffix
          echo "platform=$(echo -n ${{ matrix.platform }} | sed 's/\//-/g')" >> $GITHUB_OUTPUT

      - uses: actions/checkout@v3

      # Set up QEMU (for cross-platform builds)
      - uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      # Set up Buildx
      - uses: docker/setup-buildx-action@v3

      # Build the image for each platform. Note `push: false` here, we build only.
      - name: Build Docker image (no push)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          platforms: ${{ matrix.platform }}
          tags: ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}-${{ steps.vars.outputs.platform }}

  release:
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 10

    steps:
      - name: Set variables
        id: vars
        run: |
          echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      # Log in to GHCR using GITHUB_TOKEN
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Pull the images built previously (since we didn't push them, we need to build again here or skip pulling if already built locally)
      # However, since we never pushed in the build job, the images exist only in the builder cache, not in the registry.
      # A common pattern is to do the build and push in the same job or push intermediate images.
      # For demonstration, letâ€™s do a direct push using build-push-action again to GHCR in the release job.

      - name: Build and Push final images
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}
            ${{ env.DOCKER_REPO }}:latest

      # If you want to manually create a manifest (not strictly needed since build-push-action can handle this automatically), you could do:
      # - name: Create and push Docker manifest (if not using build-push-action to push multi-arch)
      #   run: |
      #     docker pull ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}-linux-amd64
      #     docker pull ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}-linux-arm64
      #     docker manifest create ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }} \
      #       ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}-linux-amd64 \
      #       ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}-linux-arm64
      #     docker manifest push ${{ env.DOCKER_REPO }}:${{ steps.vars.outputs.version }}
      #     docker manifest create ${{ env.DOCKER_REPO }}:latest \
      #       ${{ env.DOCKER_REPO }}:latest-linux-amd64 \
      #       ${{ env.DOCKER_REPO }}:latest-linux-arm64
      #     docker manifest push ${{ env.DOCKER_REPO }}:latest
